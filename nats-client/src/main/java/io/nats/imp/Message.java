/*
 * Copyright 2015 Apcera Inc. All rights reserved.
 */

package io.nats.imp;

import io.nats.*;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.util.CharsetUtil;

import java.util.HashMap;
import java.util.Map;

/**
 * Represents a wire-level protocol message as exchanged via the
 * <a href="http://nats.io/documentation/internals/nats-protocol/">NATS protocol
 * </a>
 */
abstract public class Message
{
  private static final byte CR_LF[] = new byte[] {'\r', '\n'};

  /**
   * Declares the protocol's message verbs. Do not modify
   * these without looking into the parsing code that is generated by
   * io.nats.tools.MessageParserGenerator...
   *
   */
  public /* static */ enum Verb
  {
    INFO,
    CONNECT,
    PUB (null, true),
    SUB,
    UNSUB,
    MSG (null, true),
    PING,
    PONG,
    OK ("+"),
    ERR ("-");

    private final String proto_name;
    private final byte proto_bytes[];

    Verb (String prefix, boolean has_body)
    {
      proto_name = (prefix != null ? prefix : "") + toString ();
      proto_bytes = proto_name.getBytes (CharsetUtil.US_ASCII);
    }

    Verb (String prefix)
    {
      this (prefix, false);
    }
    Verb () { this (null, false); }

    public void encode (ByteBuf buf)
    throws NatsException
    {
      buf.writeBytes (proto_bytes);
    }
  }

  abstract protected void encode (ByteBuf buf)
    throws NatsException;

  /* Debugging helpers only */
  protected void bodyToString (StringBuffer where)
    throws Exception
  {
    ByteBuf buff = ByteBufAllocator.DEFAULT.heapBuffer ();
    encode (buff);
    buff.readerIndex (type ().proto_bytes.length);
    buff.writerIndex (buff.writerIndex () - 2);
    final int idx = buff.indexOf (buff.readerIndex (),
                                  buff.writerIndex (),
                                  (byte) '\r');
    if (idx != -1)
      buff.writerIndex (idx);
    where.append (buff.toString (CharsetUtil.US_ASCII));
  }

  /* Debugging helper */
  public String toString ()
  {
    StringBuffer buff = new StringBuffer (super.toString ());
    buff.append ("{ \"type\":");
    buff.append (type ());
    try { bodyToString (buff); } catch (Exception e) {
      buff.append ("\n\nCaught: ");
      buff.append (e);
      buff.append (e.getStackTrace ());
    }
    buff.append ("}");
    return buff.toString ();

  }

  abstract Verb type ();

  static final Message PING = new Message ()
    {
      private byte proto_bytes[] = { 'P', 'I', 'N', 'G', '\r', '\n' };
      @Override
      Verb type () { return Verb.PING; }
      @Override
      public void encode (ByteBuf buf)
      { buf.writeBytes (proto_bytes); }
    };
  static final Message PONG = new Message ()
    {
      private byte proto_bytes[] = { 'P', 'O', 'N', 'G', '\r', '\n' };
      @Override
      public Verb type () { return Verb.PONG; }
      @Override
      public void encode (ByteBuf buf)
      { buf.writeBytes (proto_bytes); }
    };
  static final Message OK = new Message ()
    {
      private byte proto_bytes[] = {  '+', 'O', 'K', '\r', '\n' };
      @Override
      public Verb type () { return Verb.OK; }
      @Override
      public void encode (ByteBuf buf)
      { buf.writeBytes (proto_bytes); }
    };

  private static void _encode_json (ByteBuf buf, java.util.Map<String,String> map)
  {
    int count = 0;

    for (java.util.Map.Entry<String, String> entry : map.entrySet ())
      {
        String k = entry.getKey ();
        String v = entry.getValue ();
        if (k == null || k.length () == 0)
          continue;

        if (count++ != 0)
          {
            buf.writeByte (',');
            buf.writeByte (' ');
          }
        buf.writeByte ('"');
        buf.writeBytes (k.getBytes (CharsetUtil.US_ASCII));
        buf.writeByte ('"');
        buf.writeByte (':');
        if (v == null || v.equals ("true") || v.equals ("false"))
          buf.writeBytes ((v + "").getBytes (CharsetUtil.US_ASCII));
        else
          {
            buf.writeByte ('"');
            buf.writeBytes (v.getBytes (CharsetUtil.US_ASCII));
            buf.writeByte ('"');
          }
      }
  }

  static class SUB
    extends Message
  {
    public Destination subject;
    public SubscriberKey sid;
    public Destination queue;
    public SUB (Destination subject, SubscriberKey sid, Destination queue)
    {this.subject = subject; this.sid = sid; this.queue = queue;}
    public Verb type () { return Verb.SUB;  }
    @Override
    public void encode (ByteBuf buf)
      throws NatsException
    {
      Verb.SUB.encode (buf);
      buf.writeByte (' ');
      ((DestinationImpl) subject).encode (buf);
      if (queue != null)
      {
        buf.writeByte (' ');
        ((DestinationImpl) queue).encode (buf);
      }
      buf.writeByte (' ');
      buf.writeBytes (sid.rawBytes ());
      buf.writeBytes (CR_LF);

    }
  }
  static class UNSUB
    extends Message
  {
    public Destination subject;
    public long max;
    public UNSUB (Destination s, long m)
    {this.subject = s; this.max = m;}
    @Override
    public Verb type () { return Verb.UNSUB;  }
    public void encode (ByteBuf buf)
      throws NatsException
    {
      Verb.UNSUB.encode (buf);
      buf.writeByte (' ');
      ((DestinationImpl) subject).encode (buf);
      if (max >= 0)
        {
          buf.writeByte (' ');
          buf.writeBytes ((max + "").getBytes (CharsetUtil.US_ASCII));
        }
      buf.writeBytes (CR_LF);
    }
  }
  static abstract class ConnectInfoHandshake
   extends Message
  {
    public Map<String,String> handshake_params;
    public ConnectInfoHandshake ()
    { this (new HashMap<String,String> ()); }
    public ConnectInfoHandshake (Map<String,String> handshake_params)
    { this.handshake_params = handshake_params; }
    @Override
    public void encode (ByteBuf buf)
      throws NatsException
    {
      type ().encode (buf);
      buf.writeByte (' ');
      buf.writeByte ('{');
      _encode_json (buf, handshake_params);
      buf.writeByte ('}');
      buf.writeBytes (CR_LF);
    }
  }

  static class CONNECT
    extends ConnectInfoHandshake
  {
    public CONNECT (Map<String,String> connect_params) { super (connect_params); }
    public Verb type () { return Verb.CONNECT;  }
  }
  public static CONNECT CONNECT (Map<String,String> connect_params)
  {return new CONNECT (connect_params); }

  static class INFO
    extends ConnectInfoHandshake
  {
    public INFO (Map<String,String> connect_params) { super (connect_params); }
    public Verb type () { return Verb.INFO;  }
  }
  public static INFO INFO (Map<String,String> connect_params)
  {return new INFO (connect_params); }

  abstract static class MsgPub
    extends Message
  {
    public Destination subject;
    public SubscriberKey sid;
    public Destination reply_queue;
    public ByteBuf body;

    public MsgPub (Destination subject,
                   SubscriberKey sid,
                   Destination reply_queue,
                   ByteBuf body)
    {
      this.subject = subject;
      this.sid = sid;
      this.reply_queue = reply_queue;
      this.body = body;
    }
    @Override
    public void encode (ByteBuf buf)
      throws NatsException
    {
      final Verb t = type ();

      t.encode (buf);
      buf.writeByte (' ');
      ((DestinationImpl) subject).encode (buf);
      if (t == Verb.MSG)
      {
        buf.writeByte (' ');
        buf.writeBytes (sid.rawBytes ());
      }
      final Destination rq = reply_queue;
      if (rq != null)
        {
          buf.writeByte (' ');
          ((DestinationImpl) rq).encode (buf);
        }
      buf.writeByte (' ');
      final int body_size = body.readableBytes ();
      buf.writeBytes (Integer.valueOf (body_size).toString ()
                     .getBytes ((CharsetUtil.US_ASCII)));
      buf.writeBytes (CR_LF);
      final int body_ri = body.readerIndex ();
      buf.writeBytes (body);
      body.readerIndex (body_ri);
      buf.writeBytes (CR_LF);

    }
  }

  static class MSG
    extends MsgPub
    implements io.nats.Message<ByteBuf>
  {
    public MSG (Destination subject, SubscriberKey sid,
                Destination reply_queue,
                ByteBuf body)
    { super (subject, sid, reply_queue, body); }
    @Override
    public Verb type () { return Verb.MSG; }
    public Destination getSubject ()
    {
      return subject;
    }
    public Destination getReply ()
    {
      return reply_queue;
    }
    public ByteBuf getBody ()
    {
      return body;
    }
  }

  static class PUB
  extends MsgPub
  {
    public PUB (Destination subject,
                Destination reply_queue,
                ByteBuf body)
    { super (subject, null, reply_queue, body); }
    @Override
    public Verb type () { return Verb.PUB; }
  }

  static class ERR
  extends Message
  {
    public String message;

    public ERR (String message)
    {
      this.message = message;
    }
    @Override
    public Verb type () { return Verb.ERR; }
    public void encode (ByteBuf buf)
      throws NatsException
    {
        Verb.ERR.encode (buf);
        buf.writeByte (' ');
        buf.writeBytes ((message + "").getBytes (CharsetUtil.US_ASCII));
        buf.writeBytes (CR_LF);
    }

  }
}
